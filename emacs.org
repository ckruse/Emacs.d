#+TITLE: Christian's Emacs configuration
#+STARTUP: content

* Christian's Emacs configuration
** Initialisation

   Inspired by [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][Sacha Chua's Emacs configuration]], I'm using a
   minimalistic =emacs.d/init.el= file to load an org mode document
   with elisp snippets embedded. org-babel extracts the snippets and
   evaluates the code. This is the content of my =init.el=:

#+begin_src emacs-lisp  :tangle no
(require 'cask "~/.cask/cask.el")
(cask-initialize)

(require 'org)
(require 'ob-tangle)

(org-babel-load-file (expand-file-name "~/.emacs.d/emacs.org"))
#+end_src

** Keymap for my shortcuts

#+begin_src emacs-lisp
  (defvar ck/keys-minor-mode-map (make-keymap) "ck/keys-minor-mode keymap.")
#+end_src

** Personal information

#+begin_src emacs-lisp
  (setq user-full-name "Christian Kruse"
        user-mail-address "christian@kruse.cool")
#+end_src

** Emacs initialization

   I manage my package installations with the excellent [[http://cask.github.io/][Cask Package
   Manager]]. Therefore I additionally maintain a =Cask= file with all
   packages listed as dependencies. So I can easily install and update
   all packages via =cask install= and =cask update=. You can find my
   cask file at [[https://github.com/ckruse/Emacs.d/blob/master/Cask][github]].

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/site-lisp")

  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
#+end_src

*** =auto-package-update.el=

#+begin_src emacs-lisp
  (use-package auto-package-update
    :ensure t
    :pin melpa-stable
    :defer 0
    :config
    (setq auto-package-update-delete-old-versions t
          auto-package-update-interval 7)
    (auto-package-update-maybe))
#+end_src

*** Byte-compile init files to speed things up on Emacs startup

    I restart Emacs round about once a week when I upgrade my
    packages. Thus it is nice to speed things up; byte-compiling elisp
    files does exactly this.


#+begin_src emacs-lisp
(defun ck/byte-recompile ()
  (interactive)
  (byte-recompile-directory "~/.emacs.d" 0)
  (byte-recompile-directory "~/emacs.d/site-lisp" 0))
#+end_src

*** is this os x?

#+begin_src emacs-lisp
  (defun ck/is-osx ()
      (or (featurep 'ns)
          (featurep 'mac)))
#+end_src

*** Start Emacs server

    I use =emacsclient= a lot to open files via command line (I
    aliased it to =ff= (=find-file=) and =ffn= (=find-file no
    wait=)). Thus start the Emacs server to be able to use that.

#+begin_src emacs-lisp
(load "server")
(unless (server-running-p)
  (server-start))
#+end_src

*** Toolbar, Menubar, scratch message, startup screen, etc

    As a beginner the bars may be useful but for me they just suck. So
    I disable them.

#+begin_src emacs-lisp
(setq initial-scratch-message nil)
(setq initial-major-mode 'fundamental-mode)

; remove ugly and sucking toolbar
(tooltip-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

(setq inhibit-splash-screen t)
#+end_src

*** Autosave and backups

    I don't like the backup and autosave features of Emacs, thus I
    disable them.

#+begin_src emacs-lisp

(setq backup-inhibited t)
(setq-default backup-inhibited t)

(setq auto-save-default nil)
(setq-default auto-save-default nil)
(setq auto-save-list-file-prefix nil)
(setq-default auto-save-list-file-prefix nil)
(setq create-lockfiles nil)
#+end_src

*** OS X specific modifications

    On OS X the keyboard is a little bit fucked up when using Emacs. To
    avoid problems I shamelessly copied the =emulate-mac-keyboard.el=
    from the [[http://aquamacs.org/][Aquamacs project]], modified it a little bit and now using
    it.

    Although it might be weird because I use ZSH as my shell, I
    couldn't get =compilation-mode= to work with ZSH but with bash.

#+begin_src emacs-lisp
  (when (ck/is-osx)
    (setq shell-file-name "bash")
    (load "~/.emacs.d/emulate-mac-keyboard-mode")
    (emulate-mac-us-keyboard-mode)
    (setq mac-command-modifier 'super))
#+end_src

*** customizable variables

#+begin_src emacs-lisp
(defvar ck-font-name "Source Code Pro")
(defvar ck-font-size 9)
#+end_src

*** host specific configuration options

No computer is alike!

#+begin_src emacs-lisp
  (setq ck-machine-filename (concat (replace-regexp-in-string "\\..*" "" system-name) ".el"))
  (setq ck-machine-local-file (expand-file-name ck-machine-filename user-emacs-directory))
  (when (file-readable-p ck-machine-local-file)
    (load-file ck-machine-local-file))
#+end_src

*** exec path initialization

#+begin_src emacs-lisp
(defun set-exec-path-from-shell-PATH ()
  (interactive)
  (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
    (setenv "PATH" path-from-shell)
    (setq exec-path (split-string path-from-shell path-separator))))
(set-exec-path-from-shell-PATH)
#+end_src

*** Opening URLs

    Opening URLs in Emacs sucks most of the time, thus I'd like to use
    external programs (Firefox on Linux and =open= on OS X)

#+begin_src emacs-lisp
  (if (ck/is-osx)
      (setq browse-url-browser-function 'browse-url-generic
            browse-url-generic-program "open")
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "xdg-open"))
#+end_src

*** Status bar

    I like to see the current time and date in the Emacs status bar.

#+begin_src emacs-lisp
(setq display-time-24hr-format t)
(setq display-time-day-and-date t)
(setq display-time-default-load-average nil)
(display-time)
#+end_src

    Line number and column are a useful information as well.

#+begin_src emacs-lisp
(line-number-mode t)
(column-number-mode t)
#+end_src

*** Sane tab handling

    Don't get me started… ;-)

#+begin_src emacs-lisp
(setq tab-width 2)
(setq-default tab-width 2)
(setq indent-tabs-mode nil)
(setq-default indent-tabs-mode nil)
#+end_src

*** Turn on =font-lock-mode=

    We want syntax highlighting, with maximum decorations.

#+begin_src emacs-lisp
(when (fboundp 'global-font-lock-mode)
  (global-font-lock-mode t)
  (setq font-lock-maximum-decoration t))
#+end_src

*** Use UTF-8 by default

    UTF-8 is the de-facto standard, so let's use it by default.

#+begin_src emacs-lisp
; we wanna use utf8 normally
(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
#+end_src

*** Don't ring the bell

    The audio bell is highly annoying to me, let's disable it.

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

*** Use =y-or-n-p= instead of =yes-or-no-p=

    I'm lazy. If I can type =y= instead of =yes=, I'll do that.  I
    also accidently hit =C-x C-c= sometimes, so let's assure that
    Emacs will ask if it is about to exit.

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src

*** Disabled commands

    Enable some of the disabled commands. They've been disable to
    avoid confusion for new users, but some of them are quite useful
    IMHO.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'downcase-region 'disabled nil)
#+end_src

*** Clipboard and "yank overwrites"

I'd like to use the clipboard buffer on X11.

#+begin_src emacs-lisp
(setq x-select-enable-clipboard t)
#+end_src

I'd also like to overwrite an active region with a yank.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

When we copy something from an external application and then use cut
in Emacs, the copied content is not in the kill ring. This changes
that behaviour:

#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

*** electric indentation

I don't like to have to hit =tab= on every newline, so we enable
electric indentation.

#+begin_src emacs-lisp
  ;(electric-indent-mode t)
  (global-set-key (kbd "RET") 'newline-and-indent)
#+end_src

*** Highlight current line

    Very useful to have a better overview where in the buffer the
    point is.

#+begin_src emacs-lisp
(global-hl-line-mode t)
#+end_src

*** Move by logical line, not by visual line

    By default Emacs moves lines by visual lines, but that sometimes
    sucks. Thus we use this snippet to toggle between the two
    modes. Idea by [[http://ergoemacs.org/][Xah Lee]].

#+begin_src emacs-lisp
(defun ck/toggle-line-move-visual ()
  "Toggle behavior of up/down arrow key, by visual line vs logical line."
  (interactive)
  (if line-move-visual
      (setq line-move-visual nil)
    (setq line-move-visual t)))
#+end_src

*** Safe local vars

#+begin_src emacs-lisp
(custom-set-variables
  '(safe-local-variable-values (quote ((encoding . utf-8)))))
#+end_src

*** No blinking cursor in Emacs 24.4

#+begin_src emacs-lisp
(blink-cursor-mode 0)
#+end_src

*** Make read-only regions inaccessible in minibuffer

In emacs minibuffer prompt, when you press the left arrow key, the
cursor will move back all the way over the prompt text. This is
annoying because user often will hold down 【Alt+b】 to move back by
word to edit, and when user starts to type something, emacs will say
„This is read-only.“ Then you have to manually move cursor out of the
prompt

#+begin_src emacs-lisp
(setq minibuffer-prompt-properties (quote (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))
#+end_src


** customizations file

Emacs should not polute my init.el

#+begin_src emacs-lisp
  (setq custom-file "/dev/null")
#+end_src

** Theming and fonts

*** Fonts

    I use [[https://github.com/adobe-fonts/source-code-pro][Source Code Pro]]. Period.

#+begin_src emacs-lisp
  (setq fontspec (concat ck-font-name "-" (number-to-string ck-font-size)))
  (set-default-font fontspec)
  (set-fontset-font "fontset-default" nil
                    (font-spec :size ck-font-size :name ck-font-name))
  (set-face-attribute 'default nil
                      :family ck-font-name
                      :height (* ck-font-size 10)
                      :weight 'normal
                      :width 'normal)
  (add-to-list 'default-frame-alist `(font . ,fontspec))
#+end_src

*** Theme

    I'm using the Tomorrow theme in the eighties variant.

#+begin_src emacs-lisp
  (custom-set-variables
   '(custom-safe-themes
     '("c74e83f8aa4c78a121b52146eadb792c9facc5b1f02c917e3dbb454fca931223" ; smart-mode-line-respectful
       default)))

  (use-package leuven-theme
    :ensure t
    :disabled
    :init
    (load-theme 'leuven t)
    (custom-theme-set-faces
     'leuven
     `(hl-line ((t (:background "#F6FECD"))))))

  (use-package spacemacs-theme
    :ensure t
    :init
    (load-theme 'spacemacs-dark t))
#+end_src

** Helpers

*** Open a file as root

#+begin_src emacs-lisp
(defun ck/find-file-as-root ()
  "Like `ido-find-file, but automatically edit the file with
root-privileges (using tramp/sudo), if the file is not writable by
user."
  (interactive)
  (let ((file (helm-read-file-name "Edit as root: ")))
    (unless (file-writable-p file)
      (setq file (concat "/sudo:root@localhost:" file)))
    (find-file file)))

(global-set-key (kbd "C-x F") 'ck/find-file-as-root)
#+end_src

*** Smarter beginning of line (like Sublime Text)

#+begin_src emacs-lisp
  (use-package mwim
    :ensure t
    :commands mwim-beginning-of-code-or-line mwim-end-of-code-or-line
    :bind (([home] . mwim-beginning-of-code-or-line)
           ([s-left] . mwim-beginning-of-code-or-line)
           ([end] . mwim-end-of-code-or-line)
           ([s-right] . mwim-end-of-code-or-line)))
#+end_src

*** Kill all buffers

#+begin_src emacs-lisp
(defun kill-all-buffers ()
  (interactive)
  (mapcar 'kill-buffer (buffer-list))
  (delete-other-windows))

(global-set-key (kbd "C-x K") 'kill-all-buffers)
#+end_src

** Tramp

   Tramp has problems with the ZSH, so ensure we use Bash.

#+begin_src emacs-lisp
  (eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
  (use-package tramp
    :defer t
    :init (setq tramp-use-ssh-controlmaster-options nil
                tramp-ssh-controlmaster-options nil))
#+end_src

** SSL configuration

   There are some problems with the default SSL configuration in
   Emacs. I found this in the interwebs and it works.

#+begin_src emacs-lisp
  (setq ssl-program-name "openssl s_client -ssl2 -connect %s:%p")
  (setq-default ssl-program-name "openssl s_client -ssl2 -connect %s:%p")
#+end_src

** Project management

   I'm using [[https://github.com/bbatsov/projectile][projectile]] for project management.

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :pin melpa-stable
    :defer 0
    :diminish (projectile-mode . "Ⓟ")
    :init
    (projectile-global-mode)

    (defadvice projectile-project-root (around ignore-remote first activate)
      (unless (file-remote-p default-directory) ad-do-it))

    (setq projectile-indexing-method 'find
          projectile-enable-caching t
          projectile-create-missing-test-files t))
#+end_src

** Keyboard shortcuts

I've got some global keyboard shortcuts, inherited from the 90s. I got
so much used to them that I can't get rid of them.

#+begin_src emacs-lisp
  (global-set-key [C-home] 'beginning-of-buffer)
  (global-set-key [s-up] 'beginning-of-buffer)

  (global-set-key [C-end] 'end-of-buffer)
  (global-set-key [s-down] 'end-of-buffer)

  (define-key ck/keys-minor-mode-map (kbd "M-<") 'pop-to-mark-command)
  (define-key ck/keys-minor-mode-map (kbd "C--") 'dabbrev-expand)

  (when (not (ck/is-osx))
    (define-key ck/keys-minor-mode-map (kbd "s-u") 'revert-buffer))

  (define-minor-mode ck/keys-minor-mode
    "A minor mode so that my key settings override annoying major modes."
    t " ck/keys" 'ck/keys-minor-mode-map)

  (ck/keys-minor-mode 1)

  (defun ck/minibuffer-setup-hook ()
    (ck/keys-minor-mode 0))

  (add-hook 'minibuffer-setup-hook 'ck/minibuffer-setup-hook)
  (define-key minibuffer-local-map (kbd "C--") 'dabbrev-expand)
#+end_src

*** Hydra

Hydra is a nice, relatively new package which basically gives you the
ability to repeat a command bound to a keystroke by hitting the last
key again. I instantly fell in love with it.

#+begin_src emacs-lisp
  (use-package hydra
    :ensure t
    :pin melpa-stable)
#+end_src

** Shortcuts for opening often used files

   Some of my more often used files (like my =org-mode= inbox file)
   get it's own shortcut:

#+begin_src emacs-lisp
  (define-key ck/keys-minor-mode-map "\C-ccf"
    (defhydra often-used-files (:color blue)
      "often used files"
      ("p" (find-file "~/Documents/org/passwords.org.gpg") "open passwords file")
      ("i" (find-file "~/Documents/org/inbox.org") "Open org-mode inbox file")
      ("t" (find-file "~/Documents/org/work/termitel.org") "Open termitel org-mode file")))

#+end_src

** Parens

[[https://github.com/Fuco1/smartparens][Smartparens]] really rocks, it is one of my most-used Emacs customizations.

#+begin_src emacs-lisp
  (use-package smartparens-config
    :ensure smartparens
    :pin melpa-stable
    :defer 0
    :diminish smartparens-mode
    :init
    (smartparens-global-mode)
    (show-smartparens-global-mode t)

    ;;; shamelessly stolen from spacemacs
    (defun spacemas//elixir-looking-back-special-p (expr)
      (save-excursion
        (when (or (looking-back " ")
                  (looking-back "-")) (backward-char))
        (looking-back expr)))

    (defun spacemacs//elixir-point-after-fn-p (id action context)
      (save-excursion
        (when (looking-back id) (backward-char))
        (looking-back "fn")))

    (defun spacemacs//elixir-do-end-close-action (id action context)
      (when (eq action 'insert)
        (cond ((spacemas//elixir-looking-back-special-p id)
               (insert " ") (backward-char))
              ((looking-back "(")
               (insert ") ") (backward-char) (backward-char))
              (t
               (newline-and-indent)
               (forward-line -1)
               (indent-according-to-mode)))))

    (sp-with-modes '(elixir-mode)
      (sp-local-pair
       "(" ")"
       :unless '(:add spacemacs//elixir-point-after-fn-p))
      (sp-local-pair
       "fn" "end"
       :when '(("SPC" "RET" "-" "("))
       :post-handlers '(:add spacemacs//elixir-do-end-close-action)
       :actions '(insert)))
    (sp-with-modes '(elixir-mode)
      (sp-local-pair
       "do" "end"
       :when '(("SPC" "RET"))
       :post-handlers '(:add spacemacs//elixir-do-end-close-action)
       :actions '(insert))))

  (use-package rainbow-delimiters
    :ensure t
    :commands rainbow-delimiters-mode
    :init
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+end_src

** buffer names

In Emacs each buffer has a unique name. For file buffers the name is
derived from the file name, so for example a buffer associated with
the file =README= is named =README=. This is fine as long as you don’t
open files with the same name. To ensure the uniqueness of the buffer
name Emacs will append a number to the buffer name, for example
=README<1>=. I configured it to append the directory parts to the
buffer name instead of prepending it, in this way the name is still
the most prominent info:

#+begin_src emacs-lisp
  (use-package uniquify
    :defer 0
    :init
    (setq uniquify-buffer-name-style 'post-forward uniquify-separator ":"))
#+end_src

** narrow-or-widen-dwim

=narrow-or-widen-dwim= is a nice piece of code from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless
Parentheses]] for an intuitive narrow/widen behaviour.

#+begin_src emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or defun,
  whichever applies first. Narrowing to org-src-block actually
  calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is
  already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if you
           ;; don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  (define-key ck/keys-minor-mode-map (kbd "C-x n") 'narrow-or-widen-dwim)
#+end_src

** ace-window

[[https://github.com/abo-abo/ace-window][ace-window]] is a mode based on =ace-jump-mode= which makes buffer
switching similiar to it. Very nice!

#+begin_src emacs-lisp
  (use-package ace-window
    :ensure t
    :pin melpa-stable
    :commands ace-window
    :init (progn
            (define-key ck/keys-minor-mode-map (kbd "C-x o") 'ace-window))
    :config (progn
              (set-face-attribute 'aw-leading-char-face nil :foreground "deep sky blue" :weight 'bold :height 3.0)))
#+end_src

** org-mode

   [[http://orgmode.org/][Organize your live in plain text!]]

#+begin_src emacs-lisp
  (org-babel-load-file (expand-file-name "~/.emacs.d/org-mode-conf.org"))
#+end_src

** yasnippet

[[https://github.com/capitaomorte/yasnippet][YASnippet]] is a snippet system for Emacs, similiar to TextMate's tab
triggered snippets.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :pin melpa-stable
    :defer 0
    :diminish yas-minor-mode
    :init
    (yas-global-mode 1))
#+end_src

** web-mode

As a web developer [[http://web-mode.org/][web-mode]] is a must-have. It enables
pseudo-multi-modes (for web templates, where you often have mixed
contents like CSS, JS and HTML in one file).

#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :commands web-mode

    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.html\\.eex\\'" . web-mode))
      (add-to-list 'auto-mode-alist '("\\.atom\\.eex\\'" . web-mode)))

    :config
    (progn
      (defun ck/web-mode-hook ()
        "Hooks for Web mode."
        (setq web-mode-markup-indent-offset 2
              web-mode-css-indent-offset 2
              web-mode-code-indent-offset 2
              web-mode-enable-auto-indentation nil))
      (add-hook 'web-mode-hook 'ck/web-mode-hook)
      (custom-set-variables
       '(web-mode-disable-auto-pairing t)
       '(web-mode-enable-auto-pairing nil))))
#+end_src

** company-mode

Company provides a nice autocompletion feature for Emacs,
similiar to the autocompletion provided by XCode.

#+begin_src emacs-lisp
  (use-package company-mode
    :ensure company
    :pin melpa-stable
    :defer 0
    :commands global-comany-mode
    :init
    (setq company-tooltip-limit 20
          company-tooltip-align-annotations 't
          company-idle-delay .2
          company-minimum-prefix-length 2
          company-begin-commands '(self-insert-command))
    (global-company-mode))

  (use-package company-web-html
    :ensure company-web
    :pin melpa-stable
    :commands company-web-html
    :after company-mode
    :init
    (add-hook 'web-mode-hook (lambda ()
                               (push '(company-web-html company-css) company-backends)
                               (set (make-local-variable 'company-minimum-prefix-length) 0))))

  (use-package company-ansible
    :ensure t
    :pin melpa-stable
    :commands company-ansible
    :after company-mode
    :init
    (add-to-list 'company-backends 'company-ansible))
#+end_src

** C/C++ modifications

Just indentation in a sane way.

#+begin_src emacs-lisp
(defun ck-init-c ()
  (if (string-match "/postgres/" buffer-file-name)
      (progn
        (c-set-style "postgresql")
        (setq c-basic-offset 2)
        (setq-default c-basic-offset 2))

    (progn
      (c-set-style "bsd")
      (setq c-basic-offset 2)
      (c-set-offset 'arglist-cont 0)
      (c-set-offset 'arglist-intro 2)
      (c-set-offset 'case-label 2)
      (c-set-offset 'arglist-close 0))))

(add-hook 'c-mode-hook 'ck-init-c)
(add-hook 'c++-mode-hook 'ck-init-c)
#+end_src

** CMake support

We want to be able to edit CMake files in a sane way.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :ensure t
    :pin melpa-stable
    :commands cmake-mode
    :init (progn
            (add-to-list 'auto-mode-alist '(".cmake" . cmake-mode))
            (add-to-list 'auto-mode-alist '("CMakeLists.txt" . cmake-mode))))
#+end_src

** Erlang support

#+begin_src emacs-lisp
  (defun erl-get-lib-path (path)
    (format "%s/%s/emacs" path (car (directory-files path nil "^tools"))))

  (cond
   ((file-exists-p "/usr/local/lib/erlang")
    (setq load-path (cons (erl-get-lib-path "/usr/local/lib/erlang/lib") load-path))
    (setq erlang-root-dir "/usr/local/lib/erlang")
    (require 'erlang-start))

   ((file-exists-p "/usr/lib/erlang")
    (setq load-path (cons (erl-get-lib-path "/usr/lib/erlang/lib") load-path))
    (setq erlang-root-dir "/usr/lib/erlang")
    (require 'erlang-start)))

#+end_src

** expand-region

[[https://github.com/magnars/expand-region.el][expand-region]] is an Emacs extension to increase selected region by semantic units.

#+begin_src emacs-lisp
  (use-package expand-region
    :ensure t
    :pin melpa-stable
    :commands expand-region
    :init
    (define-key ck/keys-minor-mode-map "\C-cce"
      (defhydra expand-region (:color red)
        "expand region as a hydra"
        ("e" er/expand-region "Expand region"))))
#+end_src

** flycheck

   [[https://github.com/flycheck/flycheck][Flycheck]] is a nice mode for on-the-fly syntax checking.

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :pin melpa-stable
    :commands global-flycheck-mode
    :diminish flycheck-mode
    :init (add-hook 'after-init-hook #'global-flycheck-mode)
    :config
    (setq flycheck-check-syntax-automatically '(mode-enabled new-line save))
    (setq flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc javascript-jshint))
    (setq-default flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc javascript-jshint))

    (defun my/use-eslint-from-node-modules ()
      (let* ((root (locate-dominating-file
                    (or (buffer-file-name) default-directory)
                    "node_modules"))
             (eslint (and root
                          (expand-file-name "node_modules/eslint/bin/eslint.js"
                                            root))))

        (when (and eslint (file-executable-p eslint))
          (setq-local flycheck-javascript-eslint-executable eslint))))

    (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules))
#+end_src

** flyspell

[[http://www.emacswiki.org/emacs/FlySpell][Fly Spell]] enables on-the-fly spell checking in Emacs.

#+begin_src emacs-lisp
(defun fd-switch-dictionary()
  (interactive)
  (let* ((dic ispell-current-dictionary)
         (change (if (string= dic "deutsch") "en" "deutsch")))
    (ispell-change-dictionary change)
    (message "Dictionary switched from %s to %s" dic change)))

(add-hook 'mail-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)
(add-hook 'rst-mode-hook 'flyspell-mode)

(setq ispell-program-name "aspell")
#+end_src

** ibuffer

   [[http://www.emacswiki.org/emacs/IbufferMode][IBuffer]] is an advanced replacement for BufferMenu. Very neat for
   switching buffers and such.

#+begin_src emacs-lisp
  (use-package ibuffer
    :commands ibuffer
    :init
    (define-key ck/keys-minor-mode-map (kbd "C-x C-b") 'ibuffer)

    (defun ck/define-projectile-filter-groups ()
      (when (boundp 'projectile-known-projects)
        (setq my/project-filter-groups
              (mapcar
               (lambda (it)
                 (let ((name (file-name-nondirectory (directory-file-name it))))
                   `(,name (filename . ,(expand-file-name it)))))
               projectile-known-projects))))

    (setq ibuffer-saved-filter-groups
          (list
           (cons "default"
                 (append
                  (ck/define-projectile-filter-groups)
                  '(("dired" (mode . dired-mode))
                    ("Org" (or
                            (mode . org-mode)))
                    ("emacs" (or
                              (name . "^\\*scratch\\*$")
                              (name . "^\\*Messages\\*$")
                              (name . "^\\*Help\\*$")
                              (name . "^\\*Flycheck error messages\\*$")))
                    ("Circe" (or
                              (mode . circe-channel-mode)
                              (mode . circe-query-mode)
                              (mode . circe-mode)
                              (mode . circe-server-mode))))))))

    (add-hook 'ibuffer-mode-hook
              (lambda ()
                (ibuffer-switch-to-saved-filter-groups "default")))
    (setq ibuffer-show-empty-filter-groups nil))
#+end_src

** magit

   [[https://github.com/magit/magit][Magit]] is an Emacs git integration. I use it all the time, it rocks.

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :pin melpa-stable
    :commands magit-status
    :init
    (when (ck/is-osx)
      (setq magit-git-executable "/usr/local/bin/git")
      (setq magit-emacsclient-executable "/usr/local/bin/emacsclient"))
    :config
    (add-to-list 'magit-no-confirm 'stage-all-changes)
    (add-to-list 'magit-no-confirm 'unstage-all-changes)
    (setq magit-save-repository-buffers nil
          magit-last-seen-setup-instructions "2.1.0"))

  (use-package git-timemachine
    :ensure t
    :commands git-timemachine)
#+end_src

** markdown support

   Editing markdown in fundamental or text-mode sucks.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :pin melpa-stable
    :commands markdown-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode)))
#+end_src

** multiple-cursor

   [[https://github.com/magnars/multiple-cursors.el][Oh the niceness…]] this is one of my most-often used features. It rocks!

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :pin melpa-stable
    :commands mc/edit-lines mc/mark-next-like-this mc/mark-previous-like-this mc/mark-all-like-this
    :init
    (define-key ck/keys-minor-mode-map "\C-ccm"
      (defhydra multicursor (:color red)
        "multicursor"
        ("v" mc/edit-lines "all lines")
        ("d" mc/mark-next-like-this "next match")
        ("p" mc/mark-previous-like-this "prev match")
        ("D" mc/mark-all-like-this "all matches"))))
#+end_src

** Perl support

   There seem to be references to =cperl-mode= in various pieces of
   code. We don't use it.

#+begin_src
(defalias 'perl-mode 'cperl-mode)
#+end_src

** PHP support

   Just indentation, nothing special.

#+begin_src emacs-lisp
  (use-package php-mode
    :ensure t
    :pin melpa-stable
    :commands php-mode
    :init
    (defun ck-init-php ()
      (setq c-basic-offset 2)
      (c-set-offset 'arglist-cont 0)
      (c-set-offset 'arglist-intro 2)
      (c-set-offset 'case-label 2)
      (c-set-offset 'arglist-close 0))

    (add-hook 'php-mode-hook 'ck-init-php))
#+end_src

** ruby support

   Mainly =auto-mode-alist= and indentation.

#+begin_src emacs-lisp
  (use-package ruby-mode
    :commands ruby-mode
    :init
    (add-hook 'ruby-mode-hook 'turn-on-font-lock)
    (add-hook 'ruby-mode-hook (lambda ()
                                (setq tab-width 2
                                      indent-tabs-mode nil
                                          ;ruby-deep-arglist nil
                                          ;ruby-deep-indent-paren nil
                                      ruby-insert-encoding-magic-comment nil)))

    (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("\\.prawn$" . ruby-mode))
    (add-to-list 'auto-mode-alist '("\\.xlsx\\.axlsx$" . ruby-mode)))

  (use-package rubocop
    :pin melpa-stable
    :ensure t
    :commands rubocop-mode
    :after ruby-mode
    :diminish rubocop-mode
    :init
    (add-hook 'ruby-mode-hook #'rubocop-mode))

  (use-package inf-ruby
    :ensure t
    :commands inf-ruby-mode
    :after ruby-mode
    :init
    (add-hook 'ruby-mode-hook 'inf-ruby-minor-mode)
    (add-hook 'compilation-filter-hook 'inf-ruby-auto-enter))

  (use-package robe
    :ensure t
    :commands robe-mode
    :after inf-ruby company
    :diminish (robe-mode . "Ⓡ")
    :init
    (add-hook 'ruby-mode-hook 'robe-mode)
    (eval-after-load 'company
      '(push 'company-robe company-backends)))
#+end_src

** Rails integration

   We use RVM (and thus =rvm-mode=).

#+begin_src emacs-lisp
  (use-package rvm
    :ensure t
    :pin melpa-stable
    :commands rvm-use-default
    :defer 0
    :init
    (rvm-use-default))
#+end_src

  =rspec-mode= for some nice RSpec integration

#+begin_src emacs-lisp
  (use-package rspec-mode
    :ensure t
    :diminish rspec-mode
    :pin melpa-stable
    :commands rspec-mode
    :init (add-hook 'ruby-mode-hook #'rspec-mode)
    :config (rspec-install-snippets))
#+end_src

  =projectile-rails= for some fancy code navigation and Rails commands in emacs

#+begin_src emacs-lisp
  (use-package projectile-rails
    :ensure t
    :after projectile
    :defer 0
    :diminish projectile-rails-mode
    :config
    (projectile-rails-global-mode)
    (define-key projectile-rails-mode-map (kbd "C-c c r") 'hydra-projectile-rails/body))
#+end_src

** Rust support

#+begin_src emacs-lisp
  (use-package rust-mode
    :ensure t
    :pin melpa-stable
    :commands rust-mode
    :init
    (setq rust-indent-unit 2)
    (setq-default rust-indent-unit 2))
#+end_src

** smart-mode-line

   Unclutters my mode line (e.g. hides minor modes).

#+begin_src emacs-lisp
  (use-package smart-mode-line
    :disabled
    :ensure t
    :pin melpa-stable
    :commands smart-mode-line sml/setup
    :init
    (use-package smart-mode-line-powerline-theme
      :ensure t)

    (setq sml/theme 'light-powerline)
    (when (ck/is-osx)
      (setq powerline-image-apple-rgb t))

    (if after-init-time (sml/setup)
      (add-hook 'after-init-hook 'sml/setup))

    :config
    (custom-set-variables
     '(sml/hidden-modes '(" hl-p" " Helm" " RuboCop" " ck/keys" " pair" " HRB" " AC" " GitGutter" " FlyC" " FlyC-" " MMM" " Rails" " yas" " SP" " WS" " MRev" " ARev" " company" " RSpec")))

    (add-to-list 'sml/replacer-regexp-list '("^~/[Ss]ites/" ":WEB:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/dev/" ":DEV:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/dev/termitel/" ":TERM:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/dev/postgres/" ":PG:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/Documents/" ":DOC:")))

  (use-package spaceline-config
    :ensure spaceline
    :config
    (spaceline-define-segment circe-track
      "Show the circe buffers with new messages. Requires
  `circe-track-mode' to be enabled."
      (tracking-status))

    (when (ck/is-osx)
      (setq powerline-image-apple-rgb t))

    (setq-default powerline-default-separator 'utf-8)
    (setq-default powerline-default-separator 'wave)

    (spaceline-toggle-input-method-off)
    (spaceline-toggle-which-function-on)
    (spaceline-toggle-hud-off)
    (spaceline-toggle-buffer-position-off)

    (spaceline-helm-mode 1)
    (spaceline-emacs-theme 'circe-track))
#+end_src

** SQL

#+begin_src emacs-lisp
  (add-hook 'sql-interactive-mode-hook
            (lambda ()
              (toggle-truncate-lines t)))

  (use-package sqlup-mode
    :ensure t
    :pin melpa-stable
    :commands sqlup-mode
    :init (progn
            (add-hook 'sql-mode-hook 'sqlup-mode)
            (add-hook 'sql-interactive-mode-hook 'sqlup-mode)))

  (defun sql-indent-string ()
    "Indents the string under the cursor as SQL."
    (interactive)
    (save-excursion
      (er/mark-inside-quotes)
      (let* ((text (buffer-substring-no-properties (region-beginning) (region-end)))
             (pos (region-beginning))
             (column (progn (goto-char pos) (current-column)))
             (formatted-text (with-temp-buffer
                               (insert text)
                               (delete-trailing-whitespace)
                               (sql-indent-buffer)
                               (replace-string "\n" (concat "\n" (make-string column (string-to-char " "))) nil (point-min) (point-max))
                               (buffer-string))))
        (delete-region (region-beginning) (region-end))
        (goto-char pos)
        (insert formatted-text))))

  (setq-default sql-product-alist
    '((ansi
       :name "ANSI"
       :font-lock sql-mode-ansi-font-lock-keywords
       :statement sql-ansi-statement-starters)

      (ms
       :name "Microsoft"
       :font-lock sql-mode-ms-font-lock-keywords
       :sqli-program sql-ms-program
       :sqli-options sql-ms-options
       :sqli-login sql-ms-login-params
       :sqli-comint-func sql-comint-ms
       :prompt-regexp "^[0-9]*>"
       :prompt-length 5
       :syntax-alist ((?@ . "_"))
       :terminator ("^go" . "go"))

      (mysql
       :name "MySQL"
       :free-software t
       :font-lock sql-mode-mysql-font-lock-keywords
       :sqli-program sql-mysql-program
       :sqli-options sql-mysql-options
       :sqli-login sql-mysql-login-params
       :sqli-comint-func sql-comint-mysql
       :list-all "SHOW TABLES;"
       :list-table "DESCRIBE %s;"
       :prompt-regexp "^mysql> "
       :prompt-length 6
       :prompt-cont-regexp "^    -> "
       :syntax-alist ((?# . "< b"))
       :input-filter sql-remove-tabs-filter)

      (postgres
       :name "Postgres"
       :free-software t
       :font-lock sql-mode-postgres-font-lock-keywords
       :sqli-program sql-postgres-program
       :sqli-options sql-postgres-options
       :sqli-login sql-postgres-login-params
       :sqli-comint-func sql-comint-postgres
       :list-all ("\\d+" . "\\dS+")
       :list-table ("\\d+ %s" . "\\dS+ %s")
       :completion-object sql-postgres-completion-object
       :prompt-regexp "^[^#>]*=[#>] "
       :prompt-length 5
       :prompt-cont-regexp "^[^#>]*=[#>] "
       :input-filter sql-remove-tabs-filter
       :terminator ("\\(^\\s-*\\\\g$\\|;\\)" . "\\g"))

      (sqlite
       :name "SQLite"
       :free-software t
       :font-lock sql-mode-sqlite-font-lock-keywords
       :sqli-program sql-sqlite-program
       :sqli-options sql-sqlite-options
       :sqli-login sql-sqlite-login-params
       :sqli-comint-func sql-comint-sqlite
       :list-all ".tables"
       :list-table ".schema %s"
       :completion-object sql-sqlite-completion-object
       :prompt-regexp "^sqlite> "
       :prompt-length 8
       :prompt-cont-regexp "^   \\.\\.\\.> "
       :terminator ";")))
#+end_src

** Swift support

#+begin_src emacs-lisp
  (use-package swift-mode
    :ensure t
    :pin melpa-stable
    :commands swift-mode
    :init
    (setq swift-indent-offset 2))
#+end_src

** JavaScript

#+begin_src emacs-lisp
  (use-package js2-mode
    :ensure t
    :pin melpa-stable
    :commands js2-mode
    :init (progn
            (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
            (add-to-list 'interpreter-mode-alist '("node" . js2-mode)))
    :config (progn
              (custom-set-variables
               '(js2-basic-offset 2))))
#+end_src

** which-function-mode

   This little mode displays the function the point is currently
   located in in the mode line.

#+begin_src emacs-lisp
(which-function-mode)

(add-to-list 'which-func-modes 'ruby-mode)
(add-to-list 'which-func-modes 'emacs-lisp-mode)
(add-to-list 'which-func-modes 'js-mode)
(add-to-list 'which-func-modes 'c-mode)
(add-to-list 'which-func-modes 'php-mode)
#+end_src

** whitespace-mode

#+begin_src emacs-lisp
  (use-package whitespace
    :diminish (whitespace-mode . "Ⓦ")
    :init
    ;(setq whitespace-global-modes '(c-mode c++-mode ruby-mode web-mode php-mode js2-mode css-mode scss-mode elixir-mode conf-space-mode))
    ;(global-whitespace-mode t)
    (setq show-trailing-whitespace t)
    (setq whitespace-line-column 120)

    (setq whitespace-style '(face tabs spaces trailing lines-tail space-before-tab newline
                                  indentation empty space-after-tab space-mark tab-mark newline-mark))

    (setq whitespace-display-mappings
          '((space-mark 32 [183] [46])
            (space-mark 160 [164] [95])
            ;(newline-mark 10 [36 10])
            (newline-mark ?\n    [?\u21A9 ?\n] [?\> ?\n])
            (tab-mark 9 [187 9] [92 9])))

    (setq ck/spaces-color "gray92")
    (setq ck/spaces-err-color "firebrick"))

    ;; (set-face-attribute 'whitespace-space nil
    ;;                     :background nil
    ;;                     :foreground ck/spaces-color)
    ;; (set-face-attribute 'whitespace-tab nil
    ;;                     :background nil
    ;;                     :foreground ck/spaces-color)
    ;; (set-face-attribute 'whitespace-newline nil
    ;;                     :background nil
    ;;                     :foreground ck/spaces-color)
    ;; (set-face-attribute 'whitespace-empty nil
    ;;                     :background nil
    ;;                     :foreground ck/spaces-err-color)
    ;; (set-face-attribute 'whitespace-line nil
    ;;                     :background nil
    ;;                     :foreground ck/spaces-err-color)
    ;; (set-face-attribute 'whitespace-trailing nil
    ;;                     :background "khaki1"
    ;;                     :foreground ck/spaces-err-color)
    ;(setq whitespace-style '(face trailing)))
#+end_src

** YAML support

#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :pin melpa-stable
    :commands yaml-mode
    :init
    (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode)))
#+end_src

** easy gists

#+begin_src emacs-lisp
  (use-package gist
    :ensure t
    :pin melpa-stable
    :commands gist-region gist-region-private gist-buffer gist-buffer-private gist-region-or-buffer gist-region-or-buffer-private)
#+end_src

** =dired= customizations

First we want some nice little extra functions for =dired=

#+begin_src emacs-lisp
(require 'dired-x)
#+end_src

When using OS X, the =ls= doesn't support =--dired=

#+begin_src emacs-lisp
(when (ck/is-osx)
  (setq dired-use-ls-dired nil))
#+end_src

** Copy filename to clipboard

#+begin_src emacs-lisp
  (defun ck-put-file-name-on-clipboard ()
    "Put the current file name on the clipboard"
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (with-temp-buffer
          (insert filename)
          (clipboard-kill-region (point-min) (point-max)))
        (message filename))))

  (defun ck-put-file-name-wo-path-on-clipboard ()
    "Put the current file name on the clipboard"
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (setq filename (file-name-nondirectory filename))
        (with-temp-buffer
          (insert filename)
          (clipboard-kill-region (point-min) (point-max)))
        (message filename))))
#+end_src

** Launcher map for not-so-often used tools

   Tools I don't use that often get its own launcher map so I remember
   them easily.

#+begin_src emacs-lisp
  (if (ck/is-osx)
      (define-key ck/keys-minor-mode-map "\C-ccl"
        (defhydra launchers (:color blue)
          "Launchers"
          ("c" calc "Calc")
          ("d" ediff-buffers "ediff")
          ("f" find-dired "find-dired")
          ("g" lgrep "lgrep")
          ("G" rgrep "rgrep")
          ("h" man "man")
          ("s" eshell-here "eshell")
          ("t" git-timemachine "git timemachine")
          ("a" magit-status "magit-status")
          ("p" sql-postgres "sql-postgres")
          ("w" whitespace-mode "toggle whitespaces")
          ("." ck-put-file-name-wo-path-on-clipboard "copy filename to clipboard")
          (":" ck-put-file-name-on-clipboard "copy filename with full path to clipboard")))

    (define-key ck/keys-minor-mode-map "\C-ccl"
      (defhydra launchers (:color blue)
        "Launchers"
        ("c" calc "Calc")
        ("d" ediff-buffers "ediff")
        ("f" find-dired "find-dired")
        ("g" lgrep "lgrep")
        ("G" rgrep "rgrep")
        ("h" man "man")
        ("s" eshell-here "eshell")
        ("t" git-timemachine "git timemachine")
        ("a" magit-status "magit-status")
        ("p" sql-postgres "sql-postgres")
        ("w" whitespace-mode "toggle whitespaces")
        ("m" mu4e "mu4e")
        ("z" (start-process-shell-command "mbsync" "*mbsync*" "mbsync -qa") "mbsync")
        ("." ck-put-file-name-wo-path-on-clipboard "copy filename to clipboard")
        (":" ck-put-file-name-on-clipboard "copy filename with full path to clipboard"))))
#+end_src

** =eshell= modifications

#+begin_src emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((proot (projectile-project-root))
           (parent (if proot
                       proot
                     (if
                         (buffer-file-name)
                         (file-name-directory (buffer-file-name))
                       default-directory)))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t))))
           (default-directory parent))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))))

  (defun eshell/x ()
    (interactive)
    (insert "exit")
    (eshell-send-input)
    (delete-window))

  (defun eshell-mode-hook-func ()
    (setq eshell-path-env (concat (getenv "PATH") ":" eshell-path-env))
    (define-key eshell-mode-map [up] 'previous-line)
    (define-key eshell-mode-map [down] 'next-line)
    (define-key eshell-mode-map (kbd "\C-x k") 'eshell/x))
    ;(setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
    ;(define-key eshell-mode-map (kbd "M-s") 'other-window-or-split))

  (add-hook 'eshell-mode-hook 'eshell-mode-hook-func)

#+end_src

** comment/uncomment line

#+begin_src emacs-lisp
  (defun endless/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
  With positive prefix, apply to N lines including current one.
  With negative prefix, apply to -N lines above.
  If region is active, apply to active region instead."
    (interactive "p")
    (if (use-region-p)
        (comment-or-uncomment-region
         (region-beginning) (region-end))
      (let ((range
             (list (line-beginning-position)
                   (goto-char (line-end-position n)))))
        (comment-or-uncomment-region
         (apply #'min range)
         (apply #'max range)))
      (forward-line 1)
      (back-to-indentation)))

  (define-key ck/keys-minor-mode-map (kbd "C-c c C-c") 'endless/comment-line-or-region)
#+end_src

** =mmm-mode=

#+begin_src emacs-lisp
  (use-package mmm-mode
    :ensure t
    :pin melpa-stable
    :defer 0
    :diminish mmm-mode
    :config (progn
              (setq mmm-global-mode 'maybe)
              (set-face-background 'mmm-default-submode-face nil)

              (mmm-add-classes
               '((embedded-sql
                  :submode sql-mode
                  :front "<<-?SQL"
                  :front-offset (end-of-line 1)
                  :back "^[ \t]*SQL$"
                  :delimiter-mode nil)))

              (mmm-add-mode-ext-class 'ruby-mode nil 'embedded-sql)
              (setq mmm-never-modes
                    (append '(ediff-mode) '(text-mode) mmm-never-modes))))
#+end_src

** go-mode

#+begin_src emacs-lisp
  (use-package go-mode
    :ensure t
    :pin melpa-stable
    :commands go-mode
    :init (progn
            (add-to-list 'exec-path (concat (getenv "HOME") "/dev/go/bin"))
            (add-to-list 'auto-mode-alist (cons "\\.go\\'" 'go-mode))
            (add-hook 'before-save-hook #'gofmt-before-save)
            (setenv "GOPATH" (concat (getenv "HOME") "/dev/go"))))
#+end_src

** elixir-mode

#+begin_src emacs-lisp
  (use-package elixir-mode
    :ensure t
    :commands elixir-mode)

  (use-package alchemist
    :ensure t
    :commands alchemist-mode
    :after elixir-mode
    :diminish (alchemist-mode . "Ⓐ")
    :init
    (add-hook 'elixir-mode-hook 'alchemist-mode))

  (use-package mix-format
    :commands mix-format mix-format-before-save
    :after elixir-mode
    :load-path "~/dev/mix-format.el/"
    :init
    (setq mixfmt-elixir (expand-file-name "~/elixir-master/bin/elixir")
          mixfmt-mix (expand-file-name "~/elixir-master/bin/mix"))
    (add-hook 'mix-format-hook '(lambda ()
                                  (if (projectile-project-p)
                                      (setq mixfmt-args (list "--dot-formatter" (concat (projectile-project-root) "/.formatter.exs")))
                                    (setq mixfmt-args nil))))
    (add-hook 'before-save-hook 'mix-format-before-save))

  (use-package flycheck-credo
    :ensure t
    :commands flycheck-credo-setup
    :init
    (eval-after-load 'flycheck
      '(flycheck-credo-setup)))
#+end_src

** helm

#+begin_src emacs-lisp
  (use-package helm-config
    :ensure helm
    :diminish helm-mode
    :pin melpa-stable
    :defer 0
    :config
    (setq helm-split-window-in-side-p t
          helm-move-to-line-cycle-in-source t
          helm-ff-search-library-in-sexp t
          helm-scroll-amount 8
          helm-mode-fuzzy-match t
          helm-buffers-fuzzy-matching t)

    (setq helm-autoresize-max-height 30
          helm-autoresize-min-height 30)

    (helm-mode 1)

    (setq helm-completing-read-handlers-alist '((describe-function . helm-completing-read-symbols)
                                                (describe-variable . helm-completing-read-symbols)
                                                (describe-symbol . helm-completing-read-symbols)
                                                (debug-on-entry . helm-completing-read-symbols)
                                                (find-function . helm-completing-read-symbols)
                                                (disassemble . helm-completing-read-symbols)
                                                (trace-function . helm-completing-read-symbols)
                                                (trace-function-foreground . helm-completing-read-symbols)
                                                (trace-function-background . helm-completing-read-symbols)
                                                (find-tag . helm-completing-read-with-cands-in-buffer)
                                                (ffap-alternate-file)
                                                (tmm-menubar)))

    (helm-autoresize-mode t)

    (global-set-key (kbd "M-y") 'helm-show-kill-ring)
    (global-set-key (kbd "C-x b") 'helm-mini)

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z") 'helm-select-action))

  (use-package helm-projectile
    :ensure t
    :after helm
    :pin melpa-stable
    :init
    (setq projectile-completion-system 'helm)
    (helm-projectile-on))
#+end_src

** Reformat XML

Pretty-print XML with =xmllint=

#+begin_src emacs-lisp
  (defun ck-xml-format ()
    "Format an XML buffer with `xmllint'."
    (interactive)
    (shell-command-on-region (point-min) (point-max)
                             "xmllint -format -"
                             (current-buffer) t
                             "*Xmllint Error Buffer*" t))

#+end_src

** css-mode config

#+begin_src emacs-lisp
  (setq css-indent-offset 2)
#+end_src

** TouchBar shortcuts

#+begin_src emacs-lisp
  (when (ck/is-osx)
    (define-key ck/keys-minor-mode-map [f1] 'org-capture)
    (define-key ck/keys-minor-mode-map [f2] (lambda ()
                                              (interactive)
                                              (find-file "~/Documents/org/inbox.org")))
    (define-key ck/keys-minor-mode-map [f3] 'magit-status)
    (define-key ck/keys-minor-mode-map [f5] 'er/expand-region))
#+end_src

** po-mode

#+begin_src emacs-lisp
  (use-package po-mode
    :ensure t
    :pin melpa-stable
    :commands po-mode
    :init (add-to-list 'auto-mode-alist '("\\.po\\'" . po-mode)))
#+end_src

** prettier integration

#+begin_src emacs-lisp
  (use-package prettier-js
    :ensure t
    :commands prettier-js-mode prettier-js
    :diminish (prettier-js-mode . "⚚")
    :init
    (add-hook 'js2-mode-hook 'prettier-js-mode)
    (add-hook 'css-mode-hook 'prettier-js-mode)
    (add-hook 'scss-mode-hook 'prettier-js-mode)
    :config
    (setq prettier-js-command "prettier-eslint"))
#+end_src

** Easier typography

#+begin_src emacs-lisp
  (use-package typo
    :ensure t
    :diminish (typo-mode . "Ⓣ")
    :init
    (add-hook 'text-mode-hook 'typo-mode)
    :config
    (setq typo-language "German")
    (typo-global-mode 1))
#+end_src

** mu4e

#+begin_src emacs-lisp
  ;; make sure mu4e is in your load-path
  (use-package mu4e
    :commands mu4e
    :if (not (ck/is-osx))
    :init
    (setq mail-user-agent 'mu4e-user-agent)
    :config
    (require 'org-mu4e)
    (require 'mu4e-contrib)

    (defun file-string (file)
      "Read the contents of a file and return as a string."

      (let ((b (find-file-noselect file))
            (str ""))
        (setq str (with-current-buffer b
                    (buffer-string)))
        (kill-buffer b)
        str))


    (setq mu4e-maildir "~/Mail"
          mu4e-sent-folder   "/Defunct/Sent"
          mu4e-drafts-folder "/Defunct/Drafts"
          mu4e-trash-folder  "/Defunct/Trash"

          mu4e-use-fancy-chars t
          mu4e-view-show-images t
          mu4e-attachment-dir "~/Downloads"
          mu4e-change-filenames-when-moving t
          mu4e-headers-full-search t
          mu4e-get-mail-command "true"
          mu4e-update-interval 60
          mu4e-hide-index-messages t
          mu4e-view-show-addresses t
          mu4e-completing-read-function 'completing-read)

    (setq mu4e-headers-fields
          '( (:human-date    .   12)
             (:flags         .    6)
             (:maildir       .   22)
             (:mailing-list  .   10)
             (:from          .   22)
             (:subject       .   nil)))

    (setq mu4e-html2text-command 'mu4e-shr2text
          mime-edit-split-message nil
          mime-edit-pgp-signers '("A99A9D73")
          mime-edit-pgp-encrypt-to-self t
          message-send-mail-function 'smtpmail-send-it
          smtpmail-default-smtp-server "localhost"
          smtpmail-smtp-server "localhost"
          ;; message-send-mail-function 'message-send-mail-with-sendmail
          ;; sendmail-program "~/dev/mail/msmtp-enqueue.sh"
          ;; message-sendmail-extra-arguments '("-a" "Defunct")
          mail-specify-envelope-from t
          message-sendmail-f-is-evil nil
          mail-envelope-from 'header
          mail-interactive t
          message-sendmail-envelope-from 'header
          user-full-name "Christian Kruse"
          message-kill-buffer-on-exit t
          mu4e-headers-include-related nil

          mu4e-sent-folder "/Defunct/Sent"
          mu4e-drafts-folder "/Defunct/Drafts"
          mu4e-compose-signature (file-string "~/dev/mail/signature-defunct")
          user-mail-address "cjk@defunct.ch")

    (bind-keys :map mu4e-view-mode-map
               ("N" . mu4e-view-headers-next-unread)
               ("P" . mu4e-view-headers-prev-unread))

    (setq mu4e-refile-folder
          (lambda (msg)
            (let ((maildir (mu4e-message-field msg :maildir))
                  (account))
              (string-match "/\\(.*?\\)/" maildir)
              (setq account (match-string 1 maildir))
              (concat "/" account "/Archiv"))))

    (add-to-list 'mu4e-bookmarks
                 '("(maildir:/Defunct/INBOX) and flag:unread"
                   "Unread in unified inbox" ?n))
    (add-to-list 'mu4e-bookmarks
                 '("maildir:/Defunct/INBOX"
                   "Unified inbox" ?i))

    ;; (defvar my-mu4e-account-alist
    ;;   '(("Defunct"
    ;;      (mu4e-sent-folder "/Defunct/Sent")
    ;;      (mu4e-drafts-folder "/Defunct/Drafts")
    ;;      (mu4e-compose-signature (file-string "~/dev/mail/signature-defunct"))
    ;;      (user-mail-address "cjk@defunct.ch"))
    ;;     ("Termitel"
    ;;      (mu4e-sent-folder "/Termitel/Sent")
    ;;      (mu4e-drafts-folder "/Termitel/Drafts")
    ;;      (mu4e-compose-signature (file-string "~/dev/mail/signature-termitel"))
    ;;      (user-mail-address "c.kruse@termitel.de"))))

    ;; (defvar my-mu4e-account nil)

    ;; (defun my-mu4e-set-account ()
    ;;   "Set the account for composing a message."
    ;;   (let* ((account
    ;;           (if mu4e-compose-parent-message
    ;;               (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
    ;;                 (string-match "/\\(.*?\\)/" maildir)
    ;;                 (match-string 1 maildir))
    ;;             (completing-read (format "Compose with account: (%s) "
    ;;                                      (mapconcat #'(lambda (var) (car var))
    ;;                                                 my-mu4e-account-alist "/"))
    ;;                              (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
    ;;                              nil t nil nil (caar my-mu4e-account-alist))))
    ;;          (account-vars (cdr (assoc account my-mu4e-account-alist))))
    ;;     (setq mu-mu4e-account account)
    ;;     (if account-vars
    ;;         (mapc #'(lambda (var)
    ;;                   (set (car var) (cadr var)))
    ;;               account-vars)
    ;;       (error "No email account found"))))

    ;; (defun my-mu4e-set-msmtp-account ()
    ;;   (setq message-sendmail-extra-arguments
    ;;         (list "-a" mu-mu4e-account)))

    ;; (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)
    (add-hook 'mu4e-compose-mode-hook 'mml-secure-message-sign-pgpmime))

  (use-package mu4e-alert
    :ensure t
    :if (not (ck/is-osx))
    :after mu4e
    :defer 0
    :init
    (mu4e-alert-set-default-style 'libnotify)

    (setq mu4e-alert-interesting-mail-query "flag:unread AND maildir:/Defunct/INBOX")

    (mu4e-alert-enable-notifications)
    (mu4e-alert-enable-mode-line-display)
    (spaceline-toggle-mu4e-alert-segment-on))
    ;; (add-hook 'message-send-mail-hook 'my-mu4e-set-msmtp-account)))
#+end_src

** Circe, IRC in Emacs

#+begin_src emacs-lisp
  (use-package circe
    :ensure t
    :defer 120
    :commands circe tracking-status
    :init
    (defun ck/irc ()
      (interactive)
      (circe "EPD-ME")
      (circe "Freenode"))

    (load "~/dev/mail/znc.el")

    :config

    ; use things like pastebin for long pastes
    (add-hook 'circe-channel-mode-hook 'enable-lui-autopaste)
    (add-hook 'circe-channel-mode-hook 'turn-on-flyspell)

    (enable-circe-color-nicks)

    (defadvice circe-command-SAY (after jjf-circe-unignore-target)
      (let ((ignored (tracking-ignored-p (current-buffer) nil)))
        (when ignored
          (setq tracking-ignored-buffers
                (remove ignored tracking-ignored-buffers))
          (message "This buffer will now be tracked."))))
    (ad-activate 'circe-command-SAY)

    (enable-circe-notifications)

    (setq circe-default-nick "cjk101010"
          circe-default-user "ckruse"
          circe-default-realname "Christian Kruse"
          circe-reduce-lurker-spam t
          lui-time-stamp-format "%H:%M"
          lui-fill-column 120

          tracking-ignored-buffers '("#indieweb" "#erlang")

          circe-network-options
          `(("EPD-ME"
             :host "cloud.defunct.ch"
             :tls t
             :nick "Christian"
             :port "6660"
             :pass ,epdme-password
             )
            ("Freenode"
             :host "cloud.defunct.ch"
             :tls t
             :nick "cjk101010"
             :port "6660"
             :pass ,freenode-password
             ))))

  (use-package lui-autopaste
    :ensure circe
    :after circe
    :commands enable-lui-autopaste)

  (use-package circe-notifications
    :ensure t
    :after circe
    :commands enable-circe-notifications)
#+end_src

** diminish bullshit

#+begin_src emacs-lisp
  (with-eval-after-load 'magit
    (diminish 'magit-auto-revert-mode)
    (diminish 'auto-revert-mode))

  (add-hook 'after-init-hook '(lambda ()
                                (diminish 'company-mode "Ⓒ")
                                (diminish 'ck/keys-minor-mode)))
#+end_src
** dashboard

#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq dashboard-items '((projects . 5)
                            (agenda . 20)))

    (setq dashboard-startup-banner 'logo)

    (dashboard-setup-startup-hook))
#+end_src
